"""File-backed registry for machine learning experiments and model artifacts."""

from __future__ import annotations

import json
import os
import shutil
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Callable, Iterable, Mapping

from pydantic import BaseModel, Field, computed_field, model_validator

__all__ = [
    "ArtifactRecord",
    "ExperimentRegistry",
    "ExperimentRunRecord",
    "HyperparameterAuditEntry",
]


def _utcnow() -> datetime:
    return datetime.now(timezone.utc)


def _ensure_utc(value: datetime) -> datetime:
    if value.tzinfo is None:
        return value.replace(tzinfo=timezone.utc)
    return value.astimezone(timezone.utc)


def _canonical_json(payload: Mapping[str, Any]) -> str:
    return json.dumps(payload, sort_keys=True, separators=(",", ":"), default=str)


def _normalise_metrics(metrics: Mapping[str, Any]) -> dict[str, float]:
    normalised: dict[str, float] = {}
    for key, raw_value in metrics.items():
        try:
            value = float(raw_value)
        except (TypeError, ValueError) as exc:  # pragma: no cover - defensive guard
            msg = f"Metric '{key}' must be numeric. Received {raw_value!r}"
            raise TypeError(msg) from exc
        normalised[key] = value
    return normalised


def _validate_path_component(value: str, *, label: str) -> str:
    """Ensure *value* is a safe single path component."""

    if not value:
        msg = f"{label} must not be empty."
        raise ValueError(msg)
    candidate = Path(value)
    if candidate.is_absolute():
        msg = f"{label} must not be an absolute path."
        raise ValueError(msg)
    parts = candidate.parts
    if len(parts) != 1:
        msg = f"{label} must not contain path separators."
        raise ValueError(msg)
    component = parts[0]
    if component in {".", ".."}:
        msg = f"{label} must not reference parent or current directories."
        raise ValueError(msg)
    if any(sep and sep in component for sep in (os.sep, os.altsep) if sep):
        msg = f"{label} must not contain path separators."
        raise ValueError(msg)
    if "\\" in component:
        msg = f"{label} must not contain path separators."
        raise ValueError(msg)
    return component


class ArtifactRecord(BaseModel):
    """Lightweight descriptor of an artifact created during training or evaluation."""

    name: str = Field(..., description="Human readable name of the artifact.")
    uri: str = Field(
        ...,
        description="URI that locates the artifact (can be local path or remote storage URI).",
    )
    kind: str = Field(
        default="generic",
        description="Machine readable kind of the artifact (e.g. 'model', 'metrics', 'plot').",
    )
    metadata: dict[str, Any] = Field(
        default_factory=dict,
        description="Optional structured metadata to help interpret the artifact.",
    )


class ExperimentRunRecord(BaseModel):
    """Snapshot of a single experiment execution."""

    run_id: str = Field(..., description="Unique identifier of the run.")
    experiment_name: str = Field(
        ..., description="Name of the experiment the run belongs to."
    )
    created_at: datetime = Field(
        default_factory=_utcnow,
        description="UTC timestamp for when the run was registered.",
    )
    params: dict[str, Any] = Field(
        default_factory=dict, description="Hyperparameters used during training."
    )
    metrics: dict[str, float] = Field(
        default_factory=dict,
        description="Evaluation metrics captured at the end of the run.",
    )
    artifacts: list[ArtifactRecord] = Field(
        default_factory=list,
        description="Artifacts generated by the run.",
    )
    tags: set[str] = Field(
        default_factory=set, description="Optional set of tags to help discover runs."
    )
    notes: str | None = Field(
        default=None, description="Free-form notes describing the run."
    )
    parent_run_id: str | None = Field(
        default=None,
        description="Identifier of the run this execution builds upon.",
    )
    training_data_hash: str | None = Field(
        default=None,
        description="Fingerprint representing the training dataset used for the run.",
    )
    code_revision: str | None = Field(
        default=None,
        description="Source control revision that produced the run.",
    )

    @model_validator(mode="after")
    def _normalise(self) -> "ExperimentRunRecord":
        self.created_at = _ensure_utc(self.created_at)
        self.metrics = _normalise_metrics(self.metrics)
        self.tags = set(sorted(self.tags))
        return self

    @computed_field(return_type=str)
    def param_hash(self) -> str:
        """Stable hash of the hyperparameters used for quick reproducibility checks."""

        payload = _canonical_json(self.params)
        return uuid.uuid5(uuid.NAMESPACE_URL, payload).hex

    def reproducibility_manifest(self) -> dict[str, Any]:
        """Return a manifest describing everything required to reproduce the run."""

        return {
            "run_id": self.run_id,
            "experiment": self.experiment_name,
            "created_at": self.created_at.isoformat(),
            "param_hash": self.param_hash,
            "params": self.params,
            "metrics": self.metrics,
            "artifacts": [
                artifact.model_dump(mode="json") for artifact in self.artifacts
            ],
            "tags": sorted(self.tags),
            "notes": self.notes,
            "training_data_hash": self.training_data_hash,
            "code_revision": self.code_revision,
            "parent_run_id": self.parent_run_id,
        }


class HyperparameterAuditEntry(BaseModel):
    """Audit information capturing hyperparameter and metric deltas."""

    run_id: str
    compared_to: str | None
    created_at: datetime
    changed_params: dict[str, Mapping[str, Any]] = Field(default_factory=dict)
    metrics_delta: dict[str, Mapping[str, float | None]] = Field(default_factory=dict)


def _diff_params(
    previous: Mapping[str, Any], current: Mapping[str, Any]
) -> dict[str, Mapping[str, Any]]:
    diff: dict[str, Mapping[str, Any]] = {}
    keys = set(previous) | set(current)
    for key in sorted(keys):
        if key not in previous:
            diff[key] = {"change": "added", "current": current[key]}
        elif key not in current:
            diff[key] = {"change": "removed", "previous": previous[key]}
        else:
            if previous[key] != current[key]:
                diff[key] = {
                    "change": "modified",
                    "previous": previous[key],
                    "current": current[key],
                }
    return diff


def _metrics_delta(
    previous: Mapping[str, float], current: Mapping[str, float]
) -> dict[str, Mapping[str, float | None]]:
    delta: dict[str, Mapping[str, float | None]] = {}
    keys = set(previous) | set(current)
    for key in sorted(keys):
        current_value = current.get(key)
        previous_value = previous.get(key)
        change = None
        if previous_value is not None and current_value is not None:
            change = current_value - previous_value
        delta[key] = {
            "current": current_value,
            "previous": previous_value,
            "change": change,
        }
    return delta


class ExperimentRegistry:
    """File-backed experiment registry storing run history, artifacts, and audit metadata."""

    def __init__(
        self,
        base_dir: Path,
        *,
        clock: Callable[[], datetime] | None = None,
        run_id_factory: Callable[[], str] | None = None,
        fsync: bool = True,
    ) -> None:
        self._base_dir = Path(base_dir)
        self._base_dir.mkdir(parents=True, exist_ok=True)
        self._clock = clock or _utcnow
        self._run_id_factory = run_id_factory or (lambda: uuid.uuid4().hex)
        self._fsync = fsync

    def register_run(
        self,
        experiment_name: str,
        *,
        params: Mapping[str, Any] | None = None,
        metrics: Mapping[str, Any] | None = None,
        artifacts: Iterable[ArtifactRecord | Mapping[str, Any]] | None = None,
        tags: Iterable[str] | None = None,
        notes: str | None = None,
        parent_run_id: str | None = None,
        training_data_hash: str | None = None,
        code_revision: str | None = None,
    ) -> ExperimentRunRecord:
        """Create and persist a new experiment run."""

        experiment_name = _validate_path_component(
            experiment_name, label="Experiment name"
        )
        run_id = _validate_path_component(
            self._run_id_factory(), label="Run identifier"
        )
        created_at = self._clock()
        artifact_models = [
            (
                artifact
                if isinstance(artifact, ArtifactRecord)
                else ArtifactRecord.model_validate(artifact)
            )
            for artifact in (artifacts or [])
        ]
        record = ExperimentRunRecord(
            run_id=run_id,
            experiment_name=experiment_name,
            created_at=created_at,
            params=dict(params or {}),
            metrics=dict(metrics or {}),
            artifacts=artifact_models,
            tags=set(tags or set()),
            notes=notes,
            parent_run_id=parent_run_id,
            training_data_hash=training_data_hash,
            code_revision=code_revision,
        )
        self._persist_record(record)
        return record

    def list_runs(self, experiment_name: str) -> list[ExperimentRunRecord]:
        """Return all runs for *experiment_name* ordered by creation time."""

        experiment_name = _validate_path_component(
            experiment_name, label="Experiment name"
        )
        experiment_dir = self._base_dir / experiment_name
        if not experiment_dir.exists():
            return []
        records: list[ExperimentRunRecord] = []
        for run_dir in sorted(experiment_dir.iterdir()):
            run_file = run_dir / "run.json"
            if run_file.is_file():
                records.append(self._load_record(run_file))
        records.sort(key=lambda record: record.created_at)
        return records

    def get_run(
        self, run_id: str, *, experiment_name: str | None = None
    ) -> ExperimentRunRecord:
        """Retrieve a previously registered run."""

        run_id = _validate_path_component(run_id, label="Run identifier")
        candidate_paths: list[Path] = []
        if experiment_name is not None:
            experiment_name = _validate_path_component(
                experiment_name, label="Experiment name"
            )
            candidate_paths.append(self._path_for_run(experiment_name, run_id))
        else:
            for experiment_dir in self._base_dir.iterdir():
                candidate = experiment_dir / run_id / "run.json"
                if candidate.exists():
                    return self._load_record(candidate)
        for path in candidate_paths:
            if path.exists():
                return self._load_record(path)
        raise KeyError(f"Run '{run_id}' not found")

    def audit_trail(self, experiment_name: str) -> list[HyperparameterAuditEntry]:
        """Compute an audit trail describing hyperparameter and metric changes between runs."""

        runs = self.list_runs(experiment_name)
        audit_entries: list[HyperparameterAuditEntry] = []
        previous: ExperimentRunRecord | None = None
        for record in runs:
            entry = HyperparameterAuditEntry(
                run_id=record.run_id,
                compared_to=previous.run_id if previous else None,
                created_at=record.created_at,
                changed_params=_diff_params(
                    previous.params if previous else {}, record.params
                ),
                metrics_delta=_metrics_delta(
                    previous.metrics if previous else {}, record.metrics
                ),
            )
            audit_entries.append(entry)
            previous = record
        return audit_entries

    def reproducibility_manifest(
        self, run_id: str, *, experiment_name: str | None = None
    ) -> dict[str, Any]:
        """Return a manifest describing how to reproduce a run."""

        record = self.get_run(run_id, experiment_name=experiment_name)
        return record.reproducibility_manifest()

    def delete_run(self, run_id: str, *, experiment_name: str) -> None:
        """Remove a persisted run and clean up empty experiment directories."""

        experiment_name = _validate_path_component(
            experiment_name, label="Experiment name"
        )
        run_id = _validate_path_component(run_id, label="Run identifier")
        run_dir = self._base_dir / experiment_name / run_id
        run_file = run_dir / "run.json"
        if not run_file.exists():
            raise KeyError(
                f"Run '{run_id}' not found in experiment '{experiment_name}'"
            )

        shutil.rmtree(run_dir)

        experiment_dir = run_dir.parent
        if experiment_dir.exists():
            try:
                next(experiment_dir.iterdir())
            except StopIteration:
                try:
                    experiment_dir.rmdir()
                except OSError:
                    pass

    def _path_for_run(self, experiment_name: str, run_id: str) -> Path:
        experiment_name = _validate_path_component(
            experiment_name, label="Experiment name"
        )
        run_id = _validate_path_component(run_id, label="Run identifier")
        return self._base_dir / experiment_name / run_id / "run.json"

    def _persist_record(self, record: ExperimentRunRecord) -> None:
        run_path = self._path_for_run(record.experiment_name, record.run_id)
        run_path.parent.mkdir(parents=True, exist_ok=True)
        payload = record.model_dump(mode="json")
        tmp_path = run_path.with_suffix(".tmp")
        with tmp_path.open("w", encoding="utf-8") as handle:
            json.dump(payload, handle, indent=2, sort_keys=True)
            handle.flush()
            if self._fsync:
                os.fsync(handle.fileno())
        os.replace(tmp_path, run_path)

    def _load_record(self, path: Path) -> ExperimentRunRecord:
        with path.open("r", encoding="utf-8") as handle:
            payload = json.load(handle)
        return ExperimentRunRecord.model_validate(payload)
