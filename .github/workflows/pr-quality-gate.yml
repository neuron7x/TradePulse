name: PR Quality Gate

on:
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  quality-gate:
    name: Quality Gate Orchestrator
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Generate quality check matrix
        id: set-matrix
        run: |
          echo 'matrix={"check":["lint","tests","security","build","coverage"]}' >> $GITHUB_OUTPUT

      - name: Quality gate info
        run: |
          cat << 'EOF'
          ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
          ‚ïë                    PR QUALITY GATE                             ‚ïë
          ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
          ‚ïë This workflow orchestrates comprehensive quality checks:       ‚ïë
          ‚ïë                                                                ‚ïë
          ‚ïë ‚úì Code Quality & Linting                                      ‚ïë
          ‚ïë   - Ruff, Black, MyPy, Shellcheck                             ‚ïë
          ‚ïë   - Pre-commit hooks validation                               ‚ïë
          ‚ïë   - Slotscheck & secret scanning                              ‚ïë
          ‚ïë                                                                ‚ïë
          ‚ïë ‚úì Comprehensive Testing                                       ‚ïë
          ‚ïë   - Unit tests (Python 3.11, 3.12, 3.13)                     ‚ïë
          ‚ïë   - Integration tests                                         ‚ïë
          ‚ïë   - Property-based tests (Hypothesis)                         ‚ïë
          ‚ïë   - E2E smoke tests                                           ‚ïë
          ‚ïë   - Mutation tests (critical paths)                           ‚ïë
          ‚ïë                                                                ‚ïë
          ‚ïë ‚úì Security Scanning                                           ‚ïë
          ‚ïë   - Bandit (Python security)                                  ‚ïë
          ‚ïë   - Safety & pip-audit (dependencies)                         ‚ïë
          ‚ïë   - CodeQL analysis                                           ‚ïë
          ‚ïë   - Container scanning (Trivy & Grype)                        ‚ïë
          ‚ïë                                                                ‚ïë
          ‚ïë ‚úì Build Verification                                          ‚ïë
          ‚ïë   - Python wheels (Ubuntu, Windows, macOS)                    ‚ïë
          ‚ïë   - SBOM generation (CycloneDX)                               ‚ïë
          ‚ïë                                                                ‚ïë
          ‚ïë ‚úì Coverage Requirements                                       ‚ïë
          ‚ïë   - Line coverage ‚â•97%                                        ‚ïë
          ‚ïë   - Branch coverage ‚â•90%                                      ‚ïë
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
          EOF

  check-workflows:
    name: Wait for Required Workflows
    runs-on: ubuntu-latest
    needs: quality-gate
    strategy:
      fail-fast: false
      matrix:
        workflow:
          - 'Lint & Code Quality'
          - 'Tests'
          - 'Security Scan'
          - 'Build & Verify Python Wheels'
          - 'CycloneDX SBOM'
          - 'Coverage'
          - 'Mutation Tests'
          - 'Nightly Smoke E2E'
    steps:
      - name: Check ${{ matrix.workflow }} status
        uses: actions/github-script@v7
        with:
          script: |
            const workflowName = '${{ matrix.workflow }}';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = context.payload.pull_request.head.sha;
            
            // Wait for workflow to appear (it might not have started yet)
            let attempts = 0;
            const maxAttempts = 30;
            let workflowRun = null;
            
            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                event: 'pull_request',
                head_sha: ref,
                per_page: 100
              });
              
              workflowRun = runs.data.workflow_runs.find(run => 
                run.name === workflowName && 
                run.head_sha === ref
              );
              
              if (workflowRun) {
                console.log(`Found workflow: ${workflowName}`);
                break;
              }
              
              attempts++;
              console.log(`Waiting for ${workflowName} to start... (${attempts}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
            }
            
            if (!workflowRun) {
              core.warning(`Workflow ${workflowName} not found after ${maxAttempts} attempts`);
              return;
            }
            
            // Wait for completion
            const conclusion = workflowRun.conclusion;
            const status = workflowRun.status;
            
            console.log(`${workflowName}: status=${status}, conclusion=${conclusion}`);
            
            if (status !== 'completed') {
              core.warning(`${workflowName} is still running (${status})`);
            } else if (conclusion === 'success') {
              core.info(`‚úÖ ${workflowName} passed`);
            } else if (conclusion === 'failure') {
              core.setFailed(`‚ùå ${workflowName} failed`);
            } else {
              core.warning(`‚ö†Ô∏è ${workflowName} completed with status: ${conclusion}`);
            }

  quality-summary:
    name: Quality Gate Summary
    runs-on: ubuntu-latest
    needs: check-workflows
    if: always()
    steps:
      - name: Generate summary
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = context.payload.pull_request.head.sha;
            const pr_number = context.payload.pull_request.number;
            
            // Get all workflow runs for this PR
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              event: 'pull_request',
              head_sha: ref,
              per_page: 100
            });
            
            const requiredWorkflows = [
              'Lint & Code Quality',
              'Tests',
              'Security Scan',
              'Build & Verify Python Wheels',
              'CycloneDX SBOM',
              'Coverage'
            ];
            
            const optionalWorkflows = [
              'Mutation Tests',
              'Nightly Smoke E2E'
            ];
            
            let summary = '## üéØ Quality Gate Summary\n\n';
            summary += '### Required Checks\n\n';
            
            let allPassed = true;
            
            for (const workflowName of requiredWorkflows) {
              const run = runs.data.workflow_runs.find(r => r.name === workflowName);
              if (!run) {
                summary += `- ‚è≥ **${workflowName}**: Pending\n`;
                allPassed = false;
              } else if (run.conclusion === 'success') {
                summary += `- ‚úÖ **${workflowName}**: Passed\n`;
              } else if (run.conclusion === 'failure') {
                summary += `- ‚ùå **${workflowName}**: Failed\n`;
                allPassed = false;
              } else {
                summary += `- ‚ö†Ô∏è **${workflowName}**: ${run.conclusion || run.status}\n`;
              }
            }
            
            summary += '\n### Optional Checks\n\n';
            for (const workflowName of optionalWorkflows) {
              const run = runs.data.workflow_runs.find(r => r.name === workflowName);
              if (!run) {
                summary += `- ‚è≥ **${workflowName}**: Pending\n`;
              } else if (run.conclusion === 'success') {
                summary += `- ‚úÖ **${workflowName}**: Passed\n`;
              } else if (run.conclusion === 'failure') {
                summary += `- ‚ö†Ô∏è **${workflowName}**: Failed (non-blocking)\n`;
              } else {
                summary += `- ‚ÑπÔ∏è **${workflowName}**: ${run.conclusion || run.status}\n`;
              }
            }
            
            summary += '\n---\n';
            if (allPassed) {
              summary += '‚úÖ **All required quality checks passed!** This PR is ready for review.\n';
            } else {
              summary += '‚ùå **Some required checks are pending or failed.** Please review and fix issues before merging.\n';
            }
            
            console.log(summary);
            
            // Post as comment on PR
            const comments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: pr_number
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Quality Gate Summary')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr_number,
                body: summary
              });
            }

      - name: Check overall status
        if: always()
        run: |
          if [[ "${{ needs.check-workflows.result }}" == "failure" ]]; then
            echo "‚ùå Quality gate failed - some required checks did not pass"
            exit 1
          else
            echo "‚úÖ Quality gate passed - all required checks completed successfully"
          fi
