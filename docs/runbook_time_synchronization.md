# Runbook: Синхронізація часу NTP/PTP

Цей документ описує процедури контролю й підтримання точності часу в усіх
оточеннях TradePulse за допомогою NTP та PTP. Виконуйте наведені кроки, щоби
мінімізувати дрейф годинників, гарантувати достовірні часові мітки та
запобігати інцидентам, спричиненим часовими аномаліями.

## Попередні вимоги

- **Стандартизована конфігурація** – усі хости мають запускати `chronyd`,
  сконфігурований на пул `time.tradepulse.net` з резервними регіональними NTP
  пірами. Для колокаційного обладнання ввімкнено PTP (IEEE 1588) і апаратні
  часові мітки на мережевих адаптерах.
- **Автоматизація** – роль `infra.time-sync` розгортається через Ansible/Terraform
  і контролює параметри опитування, граничний дрейф (50 мс) та список запасних
  серверів. CI перериває промоцію образів, якщо `chronyc tracking` показує
  перевищення порогу.
- **Спостережуваність** – кожен сервер експортує метрики `ntp_offset_seconds` та
  `ptp_clock_class` у Prometheus. Алерти спрацьовують при |offset| > 25 мс
  (попередження) і > 40 мс (інцидент SEV-2).

## Контроль дрейфу годинників

1. **Перевірка стану**
   ```bash
   chronyc tracking
   ```
   Очікуйте `Last offset` у межах ±50 мікросекунд для вузлів із PTP та ±0.5 мс
   для NTP-only. Значення `System time` має бути «not synchronized» лише протягом
   перших 60 секунд після перезапуску служби.
2. **PTP дисципліна**
   ```bash
   pmc -u -b 0 "GET TIME_STATUS_NP"
   ```
   Поле `master_offset` має залишатися в межах ±2 мікросекунд. Якщо значення
   виходить за межі протягом >30 секунд, перевірте кабелі, QoS та пріоритети
   Boundary Clock.
3. **Автоматичні дії** – роль `infra.time-sync` виконує `chronyc burst 4/4`,
   якщо дрейф > 35 мс. Якщо після burst ситуація не нормалізується, хост
   автоматично маркується як `quarantined` у оркестраторі.

## Забезпечення точності міток подій

- **Сервіси** повинні використовувати монотонні годинники для вимірювання
  тривалостей (`time.monotonic_ns()` у Python, `CLOCK_MONOTONIC_RAW` у Go), а
  wall-clock мітки додавати лише на межах прийому/відправлення.
- **Kafka/Redpanda** – контролери перевіряють синхронізацію брокерів через
  `kafka.tools.GetOffsetShell`. Зсув часових міток >10 мс між брокерами
  спричиняє автоматичне відхилення продакшн-катоверів.
- **Зберігання** – `core.logging.TimeAlignedJSONFormatter` штампує мітки з
  precision `microseconds`, зчитані з синхронізованого системного часу.

## Запобігання часовим аномаліям

1. **Alerting** – алерт `time-sync:retrograde-detected` спрацьовує, коли
   відхилення часу від попереднього вимірювання має інший знак і перевищує 20 мс.
   У такому разі перевірте журнали `chronyd` та стан PTP GM.
2. **Моніторинг kernel** – `dmesg` не повинен містити `TIME_ERROR` або
   `pll unsynchronized`. Якщо повідомлення повторюються, виконайте `systemctl
   restart chronyd` і перевірте апаратні таймери (`hwclock --verbose`).
3. **Failover** – коли сервер позначено як `quarantined`, оркестратор виконує
   drain pod-ів і викликає прогрів резервного вузла з валідним часом.

## Синхронізація розподілених вузлів

- **Order gateway** – виконує взаємну перевірку часу з matching engine
  (`/internal/time-check`). Відхилення >5 мс призводить до перемикання на
  резервний gateway і повідомлення команди SRE.
- **Backtesting кластер** – драйвер Spark перевіряє `spark.executorEnv.TP_TIME`
  під час запуску. Якщо час відрізняється >10 мс між виконавцями, джоба не
  стартує і виводить інструкції з повторної синхронізації.
- **Market data інжектори** – порівнюють мітки з біржі з локальною стіною часу.
  Коли відхилення стабільно >3 мс, вони переходять у режим деградації і додають
  поле `"timestamp_trust": "degraded"` до повідомлень Kafka.

## Консистентність торгових потоків і логів

1. **Аудит журналів** – ETL-пайплайни очікують, що `event_time` та `ingest_time`
   відрізняються не більше ніж на 5 мс. Записи, які порушують правило, потрапляють
   до `data_quality.anomalies` для ручного перегляду.
2. **Реплікація БД** – репліки PostgreSQL перевіряють `clock_timestamp()` під час
   handshake. Якщо зсув >2 мс, репліка не підключається, доки годинники не
   синхронізовано.
3. **Регламенти** – після будь-якого SEV-2/SEV-1 інциденту, пов’язаного з часом,
   додайте постмортем до `reports/time_sync_incidents/` з полями
   `offset_peak`, `duration`, `root_cause`, `corrective_actions`.

## Процедура відновлення після інциденту

1. Зупиніть розгортання й зафіксуйте поточні offsets (`chronyc tracking`,
   `pmc`).
2. Виконайте `systemctl restart chronyd` (і `phc2sys`, якщо використовується
   апаратний PTP).
3. Підтвердіть повернення offset у допустимий діапазон протягом 5 хвилин.
4. Зніміть quarantine зі здорових вузлів і поступово поверніть трафік.
5. Оновіть постмортем і перевірте, що алерти повернулися до `OK`.

Дотримання цього runbook гарантує, що торгові стратегії, журнали та
регуляторні звіти залишаються консистентними навіть за високих навантажень і
корекцій часу.
